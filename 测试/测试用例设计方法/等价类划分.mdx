---
title: 等价类划分法
description: 等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法
keywords:
  [
    等价类,
    等价类划分,
    测试用例,
    测试用例设计,
    黑盒测试,
    基础测试用例设计,
    有效等价类,
    无效等价类,
    弱一般等价类,
    弱健壮等价类,
    强一般等价类,
    强健壮等价类,
  ]
---

import ReactECharts from "echarts-for-react";

# 等价类划分

## 定义

等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法。**采用等价类划分法时，完全不用考虑程序内部结构，设计测试用例的唯一依据是软件需求规格说明书。**

所谓等价类，是输入条件的一个子集合，该输入集合中的数据对于揭示程序中的错误是等价的。

等价类又分为**有效等价类**和**无效等价类**。有效等价类代表对程序有效的输入（利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能），而无效等价类则是其他任何可能的输入（即不正确的输入值）。有效等价类和无效等价类都是使用等价类划分法设计用例时所必须的，因为**被测程序若是正确的，就应该既能接受有效的输入，也能接受无效输入的考验。**

## 为什么使用该方法

理想的测试，是从所有可能的输入中找出某个小的子集，并且是可能发现错误最多的子集。即：**使用最少的测试数据，达到最好的测试质量（最高性价比）**。

这个子集如何确定？可以借助测试用例的两个特性：测试用例数量达到最少；某个测试用例要能覆盖大部分其他测试用例。第二个特性就暗示我们，应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理地假设测试每个等价类的代表性数据等同于测试该类的其他任何数据。这两种特性形成了称为等价类划分的黑盒测试方法。

因此，**等价类划分是黑盒测试最基本的方法**。

## 如何划分等价类

在给定了输入或外部条件之后，等价类的划分原则如下：

- 如果输入条件规定了一个取值范围（例如，“数量可以是 1 到 999”），那么就应确定出一个有效等价类（1<数量<999）,以及两个无效等价类（数量<1，数量>999）。
- 如果输入条件规定了取值的个数（例如，“汽车可登记一至六名车主”），那么就应确定出一个有效等价类和两个无效等价类（没有车主，或车主多于六个）。
- 如果输入条件规定了一个输入值的集合，而且有理由认为程序会对每个值进行不同处理（例如，“交通工具的类型必须是公共汽车、卡车、出租车、火车或摩托车”），那么就应为每个输入值确定一个有效等价类和一个无效等价类（例如，“拖车”）。
- 如果存在输入条件规定了“必须是”的情况，例如“标识符的第一个字符必须是字母”，那么就应确定一个有效等价类（首字符是字母）和一个无效等价类（首字符不是字母）。
- 以上是基于字面上的需求划分的等价类，而细化等价类依据的是数据在内存或数据库中存储的类型。（举例，测试加法器，两个文本框，要求输入-99~99 之间的整数。整数的存储在计算机底层中会使用不同的算法，正整数和负整数算法不同。所以测试时正整数和负整数应该分开来测（一般对有效等价类数据应用，无效等价类数据一般不需要正、负分别测）。所以将有效等价类细分为：-99--（-1）负整数、0—99 正整数。

> Tips：如果有任何理由可以认为程序并未等同地处理等价类中的元素，那么应该将这个等价类再划分为小一些的等价类。

**划分等价类的标准：**

- 完备测试、避免冗余;
- 划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合;
- 并是整个集合：完备性;
- 子集互不相交：保证一种形式的无冗余性;
- 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到"相同的执行路径"。

## 用例设计步骤

1. 划分等价类
   > 划分等价类是选取每一个输入条件（通常是规格说明中的一个句子或短语）并将其划分为两个或更多的组。注意，我们划分了两类等价类：有效等价类代表对程序的有效输入，而无效等价类代表的则是其他任何可能的输入条件（即不正确的输入值）。这样，我们就遵循了测试原则，即要注意无效和未预料到的输入情况。
2. 建立等价类表

   > 划分等价类后，应建立等价类表，列出与每一个输入条件对应的有效等价类和无效等价类，并为每个等价类设置一个唯一的编号。

   **使用下面的表格有利于确定测试用例**

   | 条件   | 有效等价类    | 编号   | 无效等价类 | 编号   |
   | ------ | ------------- | ------ | ---------- | ------ |
   | &nbsp; | &nbsp; &nbsp; | &nbsp; | &nbsp;     | &nbsp; |

3. 生成测试用例  
   现在利用等价类表来生成测试用例，其过程如下：
   - 编写新的测试用例，尽可能多地覆盖那些尚未被涵盖的有效等价类，直到所有的有效等价类都被测试用例所覆盖（包含进去）。
   - 编写新的用例，每次覆盖一个（仅一个）尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例所覆盖（包含进去）。

> Tips：用测试用例每次只覆盖1个无效等价类，是因为**某些特定的输入错误检查可能会屏蔽或取代其他输入错误检查**。举例，如果规格说明规定了“请输入书籍类型（硬皮、软皮或活页）及数量（1~999）”，代表两个错误输入（书籍类型错误，数量错误）的测试用例“（XYZ，0）”，很可能不会执行对数量的检查，因为程序也许会提示“XYZ是未知的书籍类型”，就不检查输入的其余部分了。

## 使用场景

有**数据输入（编辑框）**的地方，可以使用等价类划分法。例如用户登录、注册、新建、查询。

## 根据测试用例的完整性划分

完整性从弱到强排序：弱一般等价类测试、弱健壮等价类测试、强一般等价类测试、强健壮等价类测试。下面例子逐一定义。

:::info 例子
函数 y = f(x1,x2) 输入变量的取值范围分别为：x1 ∈ [10,40], x2 ∈ [50,70] , 根据规格说明（假定存在）划分得相应的等价类。  
X1：有效等价类 [10, 20)、[20, 30)、[30, 40]；无效等价类（-∞,10)、(40, +∞)  
X2：有效等价类 [50, 60)、[60, 70]；无效等价类（-∞,50)、(70, +∞)
:::

export const options = {
  xAxis: {
    name: "X1",
    min: 0,
    max: 50,
  },
  yAxis: {
    name: "X2",
    min: 40,
    max: 80,
  },
  series: [
    {
      symbolSize: 20,
      areaStyle: {
        normal: {
          color: "#8cd5c2",
        },
      },
      data: [
        [12, 55],
        [25, 65],
        [36, 54],
      ],
      type: "scatter",
    },
  ],
};

export const Func1 = () => <ReactECharts option={options} />;

**弱一般等价类**：遵循单缺陷原则，要求用例覆盖每一个变量的一种取值即可，取值为有效值。

<Func1 />

**弱健壮等价类**：在弱一般等价类的基础上，增加取值为无效值的情况。“健壮”意味着程序要有容错性，取到无效值也要正确识别出来。对于有效输入，使用每个有效值类的一个值。对于无效输入，测试用例将拥有一个无效值，并保持其余的值是有效的。

export const options3 = {
  xAxis: {
    name: "X1",
    min: 0,
    max: 50,
  },
  yAxis: {
    name: "X2",
    min: 40,
    max: 80,
  },
  series: [
    {
      symbolSize: 20,
      areaStyle: {
        normal: {
          color: "#8cd5c2",
        },
      },
      data: [
        [12, 55],
        [25, 65],
        [6, 54],
        [36, 54],
        [35, 46],
        [36, 77],
        [45, 66],
      ],
      type: "scatter",
    },
  ],
};

export const Func3 = () => <ReactECharts option={options3} />;

<Func3 />

**强一般等价类**：遵循多缺陷原则，要求用例覆盖每个变量的每种取值之间的迪卡尔乘积，即所有变量所有取值的所有组合，取值为有效值。例如变量 X 有 3 个等价类，变量 Y 有 2 个等价类，那么应设计 3\*2 共 6 个用例。要覆盖所有的有效等价类组合。

export const options2 = {
  xAxis: {
    name: "X1",
    min: 0,
    max: 50,
  },
  yAxis: {
    name: "X2",
    min: 40,
    max: 80,
  },
  series: [
    {
      symbolSize: 20,
      areaStyle: {
        normal: {
          color: "#8cd5c2",
        },
      },
      data: [
        [12, 55],
        [12, 64],
        [25, 65],
        [25, 54],
        [36, 54],
        [36, 64],
      ],
      type: "scatter",
    },
  ],
};

export const Func2 = () => <ReactECharts option={options2} />;

<Func2 />

**强健壮等价类**：在强一般等价类的基础上，增加取值为无效值的情况。（不仅取单个无效值，也要取多个无效值。）

export const options4 = {
  xAxis: {
    name: "X1",
    min: 0,
    max: 50,
  },
  yAxis: {
    name: "X2",
    min: 40,
    max: 80,
  },
  series: [
    {
      symbolSize: 20,
      areaStyle: {
        normal: {
          color: "#8cd5c2",
        },
      },
      data: [
        [5, 45],
        [6, 54],
        [5, 65],
        [5, 76],
        [12, 55],
        [13, 46],
        [14, 66],
        [16, 77],
        [25, 65],
        [25, 47],
        [26, 56],
        [24, 74],
        [36, 77],
        [35, 46],
        [34, 56],
        [34, 65],
        [36, 77],
        [45, 66],
        [45, 45],
        [45, 57],
        [45, 78],
      ],
      type: "scatter",
    },
  ],
};

export const Func4 = () => <ReactECharts option={options4} />;

<Func4 />

## 实战演练

### NextDate 函数

NextDate(年, 月, 日)是三个变量的函数。函数返回输入日期的下一个日期。变量年/月/日都是整数值，且满足下面的条件： 1900<=年<=2060 ,1<=月<=12, 1<=日<=31

1. **等价类划分**

| 条件 | 有效等价类   | 编号 | 无效等价类 | 编号 |
| ---- | ------------ | ---- | ---------- | ---- |
| 年   | 闰年         | Y1   | 年<=1900   | Y3   |
|      | 平年         | Y2   | 年>=2060   | Y4   |
| 月   | 1,3,5,7,8,10 | M1   | 月<1       | M5   |
|      | 4,6,9,11     | M2   | 月>12      | M6   |
|      | 2月          | M3   |            |      |
|      | 12月         | M4   |            |      |
| 日   | [1,28]       | D1   | 日<1       | D5   |
|      | 29           | D2   | 日>31      | D6   |
|      | 30           | D3   |            |      |
|      | 31           | D4   |            |      |

:::tip
以下测试用例输入的年月日括号内为上述对应等价类编号。
:::

2. **弱一般等价类测试**
   > 变量<font color='red'>月</font>有效等价类数量为4、变量<font color='red'>日</font>有效等价类数量为4、变量<font color='red'>年</font>有效等价类数量为2，用例覆盖每一个变量的一种取值即可，故取下面4种即可（**弱一般等价类测试用例一般为变量有效等价类最大值**）。

| 年       | 月     | 日     | 预期结果      |
| :------- | :----- | :----- | :------------ |
| 2020(Y1) | 4(M2)  | 28(D1) | 2020年4月29日 |
| 2021(Y2) | 1(M1)  | 29(D2) | 2021年1月30日 |
| 2020(Y1) | 2(M3)  | 30(D3) | 日无效        |
| 2021(Y2) | 12(M4) | 31(D4) | 2022年1月1日  |

3. **强一般等价类测试**
   > 变量<font color='red'>月/日</font>有效等价类数量为4、变量<font color='red'>年</font>有效等价类数量为2，故强一般等价类测试用例数量为4\*4\*2=32。

| 年       | 月     | 日     | 预期结果       |
| :------- | :----- | :----- | :------------- |
| 2020(Y1) | 1(M1)  | 28(D1) | 2020年1月29日  |
| 2020(Y1) | 1(M1)  | 29(D2) | 2020年1月30日  |
| 2020(Y1) | 1(M1)  | 30(D3) | 2020年1月31日  |
| 2020(Y1) | 1(M1)  | 31(D4) | 2020年2月1日   |
| 2020(Y1) | 6(M2)  | 28(D1) | 2020年6月29日  |
| 2020(Y1) | 6(M2)  | 29(D2) | 2020年6月30日  |
| 2020(Y1) | 6(M2)  | 30(D3) | 2020年6月31日  |
| 2020(Y1) | 6(M2)  | 31(D4) | 输入错误!      |
| 2020(Y1) | 2(M3)  | 28(D1) | 2020年2月29日  |
| 2020(Y1) | 2(M3)  | 29(D2) | 2020年3月1日   |
| 2020(Y1) | 2(M3)  | 30(D3) | 输入错误!      |
| 2020(Y1) | 2(M3)  | 31(D4) | 输入错误!      |
| 2020(Y1) | 12(M4) | 28(D1) | 2020年12月29日 |
| 2020(Y1) | 12(M4) | 29(D2) | 2020年12月30日 |
| 2020(Y1) | 12(M4) | 30(D3) | 2020年12月31日 |
| 2020(Y1) | 12(M4) | 31(D4) | 2021年1月1日   |
| 2021(Y2) | 1(M1)  | 28(D1) | 2021年1月29日  |
| 2021(Y2) | 1(M1)  | 29(D2) | 2021年1月30日  |
| 2021(Y2) | 1(M1)  | 30(D3) | 2021年1月31日  |
| 2021(Y2) | 1(M1)  | 31(D4) | 2021年2月1日   |
| 2021(Y2) | 6(M2)  | 28(D1) | 2021年6月29日  |
| 2021(Y2) | 6(M2)  | 29(D2) | 2021年6月30日  |
| 2021(Y2) | 6(M2)  | 30(D3) | 2021年6月31日  |
| 2021(Y2) | 6(M2)  | 31(D4) | 输入错误!      |
| 2021(Y2) | 2(M3)  | 28(D1) | 2021年2月29日  |
| 2021(Y2) | 2(M3)  | 29(D2) | 输入错误!      |
| 2021(Y2) | 2(M3)  | 30(D3) | 输入错误!      |
| 2021(Y2) | 2(M3)  | 31(D4) | 输入错误!      |
| 2021(Y2) | 12(M4) | 28(D1) | 2021年12月29日 |
| 2021(Y2) | 12(M4) | 29(D2) | 2021年12月30日 |
| 2021(Y2) | 12(M4) | 30(D3) | 2021年12月31日 |
| 2020(Y2) | 12(M4) | 31(D4) | 2022年1月1日   |

4. **弱健壮等价类测试**
   > 弱一般等价类测试用例为4，变量<font color='red'>年/月/日</font>无效等价类都为2，设计以下10种（4+2+2+2）用例。

| 年       | 月     | 日     | 预期结果       | 说明                     |
| :------- | :----- | :----- | :------------- | :----------------------- |
| 2020(Y1) | 4(M2)  | 28(D1) | 2020年4月29日  | 包含在弱一般等价类测试中 |
| 2021(Y2) | 1(M1)  | 29(D2) | 2021年1月30日  | 包含在弱一般等价类测试中 |
| 2020(Y1) | 2(M3)  | 30(D3) | 日无效         | 包含在弱一般等价类测试中 |
| 2021(Y2) | 12(M4) | 31(D4) | 2022年1月1日   | 包含在弱一般等价类测试中 |
| 1899(Y3) | 12(M2) | 31(D1) | 年无效月日有效 |                          |
| 2061(Y4) | 12(M2) | 31(D1) | 年无效月日有效 |                          |
| 2020(Y1) | 0(M5)  | 28(D1) | 月无效年日有效 |                          |
| 2021(Y2) | 13(M6) | 29(D2) | 月无效年日有效 |                          |
| 2020(Y1) | 4(M2)  | 0(D5)  | 日无效年日有效 |                          |
| 2021(Y2) | 1(M1)  | 32(D6) | 日无效年日有效 |                          |

5. **强健壮等价类测试**
   > 变量<font color='red'>年</font>等价类数为4，变量<font color='red'>月/日</font>等价类数为6，可以设计144种（4*6*6）用例，限于篇幅问题不再列举用例明细。

## 参考文档

- https://zhuanlan.zhihu.com/p/112810758
- https://www.cnblogs.com/whylaughing/p/5821812.html
- https://blog.csdn.net/m0_49449205/article/details/119703462
- 《软件测试的艺术》
