健壮性及容错性测试点

# 1. 配置文件配置项错误的处理
## 1.1 引言
对配置文件中的配置错误方面的容错性，有一些常见默认要支持的.

## 1.2 测试点描述
**[测试目的]**  
当配置文件配置项错误时，程序会有提醒不处理，而不是根据错误的配置进行错误的处理。

**[测试方法]**  
例如某配置项只有2种正确取值，尝试配置第3种取值进行测试。  
又例如，有些路径在设置为无/结尾时能正常进行文件的存放，但是有/结尾时就会在不正确的目录中存放文件或生产荣誉的垃圾信息。

# 2 文件操作失败的处理
## 2.1 引言
**操作文件/目录失败时，有异常处理：** 
有判断写失败处理，程序要么退出，要么不退出则必须保证不能影响业务继续正常处理，日志必须有告警信息输出。

## 2.2 测试点描述
**[测试目的]**  
有文件操作失败的处理，例如输入文件格式出错检查、文件从临时目录link到最终目录失败、打开文件失败、写文件失败等。通常这种情况，程序需要正常报错退出，如果允许不退出，也需要有警告信息输出到日志中。

**[测试方法]**  
通常可通过更改目录权限或目录不存在模拟文件操作异常。

# 3 输入文件异常时的处理
## 3.1 引言
事务控制方面，设计是要明确事务期间的处理情况，例如是处理一个文件为一个事务还是处理多条记录为一个事务，还是处理一批文件为一个事务。事务需保证不会存在有数据丢失情况，有重复处理情况。

## 3.2 测试点描述
**[测试目的]**   
<font color="#0000ff">验证程序批量处理数据文件时，事务控制是否和程序设定的机制一致</font>，比如，是否整个文件处理完，才提交事务，还是处理了多少条，就立马提交事务。

**[测试方法]**  
造批量测试数据的时候，批量数据里面加上一些格式错误的数据，或者会导致主键重复的数据（造这些数据的时候，要根据程序批量提交事务的点，比如，每500条记录提交一次，则失败的数据应该放在这500条之内），提交程序处理，看程序是否会整个文件回退掉，还是只回退未提交的记录。  
测试要注意观察如果程序支持重跑是否会出现被重复处理的情况。

**[故障例子]**    
2009年某日，800多用户投诉两城一家不能退费，其中400用户由于没有办理两城一家基础资料导致退费失败。  
根据投诉号码查询两城一家办理基础数据表，发现没有用户办理资料，但是原始营业上传文件中有办理资料，通过查询日志发现save2db两城一家实例程序在处理部分文件时报主键冲突异常，查询未入库原始文件存在相同记录，而程序没有做相同记录检验，并且设定事务管理批量提交，导致主键冲突事务回滚，使整个存在相同记录的文件不能入库。部分办理两城一家的用户不能成功退费。

# 4 数据库字段为空的处理
## 4.1 引言
如果确实是有用的但又可为空的字段，程序有时会通过使用nvl函数设置默认值，若程序遗漏了这一默认操作就可能会处理出错。

## 4.2 测试点描述
**[测试目的]**  
数据库表某些字段是允许为空的，需要验证这些字段确实为空时，程序是否能正常处理。

**[测试方法]**   
造数据时使得库表允许为空的字段（没有Not Null字样）为空，程序能否正常处理这些记录。

# 5 数据库异常时程序处理

## 5.1 测试点描述
**[测试目的]**  
有捕捉数据库操作失败的处理，当数据库操作失败时事务仍然完整。通常这种情况，程序需要正常报错退出。如果允许不退出，也需要有告警信息输出到日志中。

**[测试方法]**  
故意测试异常情况让数据库操作失败。例如在操作过程中数据库断开连接；操作的表不存在；操作的表无权限...

# 6 父子进程被kill的处理
## 6.1 引言
1. 服务进程，子进程数量应该保持为配置要求。如果子进程异常（异常退出、僵死、挂起等），主进程应该能够判断并能主动重新起一个子进程。  
2. 定期启动，主进程首先根据配置要求创建子进程，如果子进程被分派的任务尚未完成，而子进程已经退出，主进程应能够自动创建一个新的子进程继续完成任务；如果子进程被分派的任务已经完成，则不需要再创建新的子进程。

## 6.2 测试点描述
**[测试目的]**  
多进程处理时，父子进程被kill后，程序的处理策略：  
子进程被kill后，父进程是重新生成子进程继续正常处理下去？还是抛出异常挂起程序通知维护？是否所有原因的被kill都使用相同的处理策略（正常业务处理失败和数据库初始化失败业务有所区别）  
父进程被kill后，子进程是应该马上也被kiil，还是应该处理完一次事务所有数据再退出？  
这些进程被kill后是否应该导出数据方便查看  

**[测试方法]**   
1. 向开发了解父子进程的退出策略，讨论这些退出策略是否合理。
2. 程序常驻运行后，使用kill -30 进程号或kill 进程号观察父子进程被kill后的处理是否符合预期结果。

# 7 try-catch处理
## 7.1 测试点描述
**[测试目的]**  
代码中有try-catch操作时，了解catch{}操作中抛异常(throw)，返回处理（return），退出处理（exit）操作是否与预期相符。对于哪些异常应该退出，哪些异常应该忽略继续执行，哪些异常应该抛错终止，有确切了解。验证实际结果是否与预期相符。

**[测试方法]**   
对catch{}内捕捉的异常进行测试；对于难以进行测试的，也要进行代码走查和确认。
