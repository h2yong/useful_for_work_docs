# 正反代理和负载均衡算法

## 代理
代理就相当于中间商,本来A和B是可以直接连接的,但是此时添加了一个C在中间,A跟B不直接连接,而是通过C作为中介进行连接。  
一个完整的请求是由: client(客户端) -> proxy(代理) -> server(服务端) 

### 正向代理
**正向代理**: 顺着请求的方向进行的代理，即代理服务器它是由你配置为你服务，去请求目标服务器地址。  
**举例**: 如我们现在想要访问谷歌,但是由于某些原因,无法直接访问到谷歌,我们可以通过连接一台代理服务器,代理服务将我们的请求提交到谷歌,然后再将谷歌的响应反馈给我们。

### 反向代理
**反向代理**: 跟正向代理相反，它是为目标服务器进行服务的,但是请求的流程还是: clieng -> proxy -> server。

**举例**: 比如我们访问谷歌网站，谷歌的代理服务器对外的域名为 https://www.google.com 。具体内部的服务器节点我们不知道。现实中我们通过访问谷歌的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回。

## 什么是负载均衡
指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性

## 轮询算法（Round Robin）

- **原理**：按顺序将请求依次分配给后端服务器，循环往复。
- 优点：

  - 实现简单，无需额外计算。
  - 公平分配请求，适合服务器性能相近的场景。

- 缺点：

  - 无法感知服务器负载差异，可能导致性能差的服务器过载。
  - 不支持动态调整权重。

- **适用场景**：服务器配置相同且负载波动较小的场景，如静态资源服务器集群。

## 加权轮询（Weighted Round Robin）

- **原理**：在轮询基础上，为每台服务器分配权重，权重高的服务器获得更多请求。

- **优点**：

  - 可根据服务器性能差异灵活分配流量。
  - 支持手动配置权重，适合异构服务器环境。

- **缺点**：

  - 权重需预先静态配置，无法动态适应负载变化。
  - 长时间运行可能导致低权重服务器闲置。

- **适用场景**：服务器性能差异明显的场景（如 CPU、内存不同），需人工干预权重的环境。

## 随机算法（Random）

- **原理**：完全随机选择一个服务器处理请求。

- **优点**：

  - 实现简单，适合快速部署。
  - 在大量请求下接近均匀分布。

- **缺点**：

  - 无法保证流量分配的精准性。
  - 可能短时间集中访问某台服务器，导致局部负载过高。

- **适用场景**：服务器性能相近且对流量分配精度要求不高的场景，如测试环境。

## 加权随机（Weighted Random）

- **原理**：根据服务器权重随机分配请求，权重高的服务器被选中的概率更高。
- **优点**：

  - 结合随机性和权重分配，灵活性较高。
  - 适合需要概率性负载均衡的场景。

- **缺点**：

  - 仍依赖静态权重配置，无法实时响应服务器状态变化。
  - 流量分配不如加权轮询稳定。

- **适用场景**：需要按概率分配流量且服务器性能差异较大的场景，如混合云环境。

## 最小连接数（Least Connections）

- **原理**：优先将请求分配给当前连接数最少的服务器。
- **优点**：

  - 动态感知服务器负载，自动平衡流量。
  - 适合处理长连接或请求处理时间差异大的场景（如数据库查询）。

- **缺点**：

  - 需要实时监控服务器连接数，增加系统开销。
  - 不适用于短连接或请求处理时间均匀的场景。

- **适用场景**：长连接服务（如 WebSocket）、处理时间差异大的后端服务（如 API 网关）。

## 最短响应时间（Least Response Time）

- **原理**：综合服务器响应时间和当前连接数，选择响应最快的服务器。
- **优点**：

  - 动态优化用户体验，优先分配高性能节点。
  - 兼顾延迟和负载，适合对延迟敏感的应用。

- **缺点**：
- 需持续采集响应时间数据，计算复杂度高。
- 网络抖动可能导致决策不稳定。

- **适用场景**：高并发 Web 服务、实时应用（如在线游戏、金融交易系统）。

## 源地址哈希法( Source Hashing )

- **原理**：根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话黏滞。

## 一致性 Hash 均衡算法(ConsistentHash)

- **原理**：一致性 Hash，相同参数的请求总是发到同一个提供者。

- **优点**：

  - 一致性 Hash 算法可以解决服务提供者的增加、移除及挂掉时的情况，能尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。
  - 一致性 Hash 通过构建虚拟节点，能尽可能避免分配失衡，具有很好的平衡性。
