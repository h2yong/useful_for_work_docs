# redis面试指南
* [《吊打面试官》系列-Redis常见面试题](https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ)
* [《吊打面试官》系列-Redis基础](https://mp.weixin.qq.com/s/aOiadiWG2nNaZowmoDQPMQ)
* [《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU](https://mp.weixin.qq.com/s/EjDeypra_d9Tfsn-WkJZdw)
* [《吊打面试官》系列-分布式锁、并发竞争、双写一致性](https://mp.weixin.qq.com/s/2hTgP3MRTVDxmmoUFhOaGw)

# redis为什么这么快
1. 纯内存操作：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)
2. 单线程，无锁竞争：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；
3. 多路 I/O 复用模型，非阻塞 I/O：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；
4. 高效的数据结构，加上底层做了大量优化：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..

# 使用缓存会出现什么问题？

## 缓存雪崩问题
### 是什么
同一时间大量缓存数据失效，导致原本访问Redis的请求全部去到数据库，造成数据库短期内CPU和内存压力激增，严重时甚至造成宕机。

### 为什么
缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删除。

### 怎么解决
给缓存数据设置过期时间时加上一个随机值，这就会大幅度减少缓存在同一时间过期的情况。

## Redis 挂掉了，请求全部走数据库
另外对于 "Redis 挂掉了，请求全部走数据库" 这样的情况，我们还可以有如下的思路：

* 事发前：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。
* 事发中：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
* 事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

## 缓存穿透问题
### 是什么
查询一个不存在于数据库中的数据（如ID为负数），此时缓存一定不存在，所以就会绕过Redis请求数据库，如果查询多了也有可能把数据库拖垮。

### 为什么
请求的数据大量不命中缓存，导致走数据库。

### 怎么解决
1. 使用bloomfilter提前拦截；
2. 把不存在的空对象也放到缓存中，设置一个较短过期时间；

## 缓存击穿问题
### 是什么
就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。

### 怎么解决
1. 设置热点数据永远不过期
2. 可以使用互斥锁更新，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。

## 缓存和数据库双写一致性问题
### 是什么
当更新（更改或删除）操作发生时，导致数据库和redis中的数据不一致问题。

### 为什么
同时更新Redis和更新数据库的原子性无法得到满足，不论是先更新数据库还是Redis都有可能失败，并且在高并发下还随时伴有顺序未知的读取操作。

### 怎么解决
利用消息队列来实现消息最终一致性的保证。并且还需要利用消息队列的重试机制来保证能够更新成功，如果多次消费失败，可能是由于网络或redis挂了，需要添加告警提醒。

## redis数据结构
* String -- 缓存功能/计数器/用户session
* Hash -- 类似Map，适合用于存储对象
* List -- 粉丝列表/文章列表、队列、栈
* Set -- 去重、交集、并集、差集
* SortedSet -- 排行版/热搜版
* Bitmap -- 布隆过滤器（BloomFilter）
* HyperLogLog -- pv/uv统计
* Geospatial -- 地理位置
* Pub/Sub -- Pub/Sub构建实时消息系统

## redis高级功能

### pipline
可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。

### lua
Redis 支持提交 Lua 脚本来执行一系列的功能。

## 使用过Redis做异步队列么，你是怎么用的？
一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

## 如果对方追问可不可以不用sleep呢？
list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。

## 如果对方接着追问能不能生产一次消费多次呢？
使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。

## 如果对方继续追问 pub/sub有什么缺点？
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如kafka等。

### 如果对方追问Redis如何实现延时队列？
使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

## 持久化
Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。

RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。

AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

## Redis相比Memcached有哪些优势？
1. Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作；
2. Redis 原生支持集群模式；
3. 由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。

## Redis 常见的性能问题都有哪些？如何解决？
1. Master写内存快照，会阻塞主线程工作，所以master最好不要写快照；
2. Master AOF持久化文件过大会影响Master重启的恢复速度，所以master最好不要做任何持久化工作；
3. Redis主从复制的性能问题，Slave和Master最好在同一个局域网内；

## 那你使用过Redis分布式锁么，它是什么回事？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

## 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
这个锁就永远得不到释放了。解决方案：使用set命令将setnx和expire合成一条指令来使用。  
SETNX(set if not exists)