## 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发
MinorGC 进行垃圾回收。新生代又分为 Eden 区、 SurvivorFrom、 SurvivorTo 三个区。

### Eden 区

Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。

### SurvivorFrom

上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

### SurvivorTo

保留了一次 MinorGC 过程中的幸存者。

### MinorGC 的过程（复制->清空->互换）

MinorGC 采用复制算法。

1. eden、 survicorFrom 复制到 SurvicorTo，年龄+1  
    首先，把 Eden 和 SurvivorFrom 区域中存活的对象复制到 SurvivorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 SurvivorTo 不够位置了就放到老年区）；
2. 清空 eden、 SurvivorFrom  
    然后，清空 Eden 和 SurvivorFrom 中的对象；
3. SurvivorTo 和 SurvivorFrom 互换  
    最后， SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 时的 SurvivorFrom区。

## 老年代

主要存放应用程序中生命周期长的内存对象。
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

标记阶段的具体步骤如下：

1. 从根节点开始，遍历程序的对象图。根节点可以是全局变量、静态变量、活动线程的栈帧等。
2. 对于遍历到的每个对象，将其标记为活动对象。可以使用标记位或者其他方式进行标记。
3. 对于每个已标记的对象，继续遍历其引用的对象，并将其标记为活动对象。这个过程可以递归进行，直到遍历完所有活动对象为止。

清除阶段的具体步骤如下：

1. 遍历整个堆内存，对于每个对象，检查其是否被标记为活动对象。
2. 如果对象被标记为活动对象，则保留它，表示它仍然被程序引用，不进行清除。
3. 如果对象没有被标记为活动对象，则将其标记为未使用的内存空间，并将该内存空间加入到空闲列表中，以便后续的内存分配使用。

继续遍历堆内存中的所有对象，重复上述步骤，直到清除完所有未被标记的对象。

## 永久代
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被
放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这
也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

在 Java8 中， 永久代已经被移除，被一个称为"元数据区"（元空间）的区域所取代。元空间
的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用
本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 native
memory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由
MaxPermSize 控制，而由系统的实际可用空间来控制。


## 如何确定垃圾
为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”
对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。

要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记
过程。两次标记后仍然是可回收对象，则将面临回收。